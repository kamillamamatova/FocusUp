<!doctype html>
<html lang = "en">
    <head>
        <!--- Meta charset for proper text rendering -->
        <meta charset = "utf-8" />
        <!-- Responsive layout on mobile -->
         <meta name = "viewport" content = "width=device-width, initial-scale=1" />
         <!-- Page title shown in the browser tab -->
          <title>Focus Timer - Goal + Streaks</title>
          <!-- Minimal, clean styling with CSS variable for easy theming -->
           <style>
            :root{ --bg: #0f172a; --card: #111827; --muted: #94a3b8; --text: #e5e7eb; --accent: #22c55e; --accent2: #38bdf8; --danger: #ef4444;}
            *{ box-sizing: border-box;}
            body{ margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background: var(--bg); color: var(--text); display: flex; justify-content: center; padding: 20px;}
            .wrap{ width: min(820px, 100%);}
            .card{ background: linear-gradient(180deg, #0b1220, var(--card)); border: 1px solid #1f2937; border-radius: 16px; padding: 20px; box-shadow: 0 10px 30px rgba(0, 0, 0, 25);}
            h1{ margin: 0 0 6px; font-size: 24px; line-height: 1.2;}
            .sub{ color: var(--muted); margin-bottom: 16px;}
            .row{ display: flex; gap: 14px; flex-wrap: wrap;}
            .block{ flex: 1 1 180px; background: #0b1320; border: 1px solid #1f2937; border-radius: 12px; padding: 14px; min-width: 180px;}
            .big{ font-size: 44px; font-weight: 700; letter-spacing: 1px;}
            .label{ color: var(--muted); font-size: 12px; text-transform: uppercase; letter-spacing: .08em;}
            .controls{ display: flex; gap: 10px; flex-wrap: wrap; margin-top: 12px;}
            button{ cursor: pointer; border: none; border-radius: 10px; padding: 12px 16px; font-weight: 600; color: #0b1220; background: #e5e7eb;}
            button.primary{ background: var(--accent); color: #072312;}
            button.info{ background: var(--accent2); color: #041a23;}
            button.danger{ background: var(--danger); color: #23070b;}
            input[type = "number"]{ width: 110px; padding: 10px 12px; border-radius: 10px; border: 1px solid #1f2937; background: #0b1320; color: var(--text);}
            .pill{ display: inline-block; padding: 6px 10px; border-radius: 999px; font-size: 12px; border: 1px solid #1f2937; color: var(--muted);}
            .grid{ display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 16px;}
            .history{ max-height: 220px; overflow: auto; border: 1px solid #1f2937; border-radius: 12px;}
            .history table{ width: 100%; border-collapse: collapse;}
            .history th, .history td{ padding: 10px 12px; border-bottom: 1px solid #1f2937; text-align: left; font-size: 14px;}
            .muted{ color: var(--muted);}
            .ok{ color: var(--accent); font-weight: 700;}
            .warn{ color: #fbbf24; font-weight: 700;}
            .neg{ color: #60a5fa; font-weight: 700;}
            .footer{ margin-top: 10px; color: var(--muted); font-size: 12px;}
            @media(max-width: 720px){ .grid{ grid-template-columns: 1fr; } .big{ font-size: 38px;}}
           </style>
    </head>
    <body>
        <!-- Outer container -->
         <div class = "wrap">
            <!-- Main card container -->
             <div class = "card">
                <!-- App heading -->
                 <h1>Focus Timer</h1>
                 <!-- Short description line -->
                  <div class = "sub">Count up toward a daily goal, log the day, and keep your streak alive.</div>
                  
                  <!-- Key Performance Indicator (KPI) showing -->
                   <div class = "row">
                    <!-- Elapsed block -->
                     <div class = "block">
                        <div class = "label">Elapsed</div>
                        <div id = "elapsed" class = "big">00:00:00</div>
                     </div>
                     <!-- Remaining block (until goal) -->
                      <div class = "block">
                        <div class = "label">Remaining to goal</div>
                        <div id = "remaining" class = "big">02:00:00</div>
                      </div>
                      <!-- Overtime block (after goal) -->
                       <div class = "block">
                        <div class = "label">Overtime</div>
                        <div id = "overtime" class = "big">00:00:00</div>
                       </div>
                   </div>

                   <!-- Control row -->
                    <div class = "controls">
                        <!-- Start/pause toggle button -->
                         <button id = "StartPauseBtn" class = "primary">Start</button>
                         <!-- Reset current session timer -->
                          <button id = "ResetBtn" class = "danger">Reset</button>
                          <!-- Finish Day logs today's minutes and updates streaks -->
                           <button id = "FinishDayBtn" class = "info">Finish Day</button>
                           <!-- Numeric input for daily goal (minutes) -->
                            <label class = "pill">Goal (mins): <input id = "goalInput" type = "number" min = "1" step = "5" value = "120"></label>
                            <!-- Session counter display -->
                             <span id = "sessionsPill" class = "pill">Sessions today: 0</span> 
                             <!-- Status pill that flips when goal is met -->
                              <span id = "statusPill" class = "pill">Status: working...</span>
                    </div>
                    
                    <!-- Secondary grid: streak info + history table -->
                     <div class = "grid">
                        <!-- Streaks panel -->
                         <div class = "block">
                            <div class = "label">Streaks</div>
                            <div style = "display: flex; gap: 14px; margin-top: 6px;">
                                <div>
                                    <div class = "muted">Current</div>
                                    <div id = "currentStreak" class = "big">0</div>
                                </div>
                                <div>
                                    <div class = "muted">Best</div>
                                    <div id = "bestStreak" class = "big">0</div>
                                </div>
                            </div>
                            <div class = "footer">A day counts if minutes >= goal. "Finish Day" records the total.</div>
                         </div>

                         <!-- History panel -->
                          <div class = "block">
                            <div class = "label">History</div>
                            <div class = "history" id = "historyBox">
                                <!-- Table shell created by JS -->
                            </div>
                            <div class = "footer">Tip: Export/backup localStorage if switching browsers.</div>
                          </div>
                     </div>
             </div>
         </div>

         <!-- App logic in vanilla JS -->
          <script>
            // Utilities
            // Formats seconds to HH:MM:SS string
            const fmt = s => {
                // Keeps minus sign for negative values
                const sign = s < 0 ? "-" : "";
                // Absolute seconds, rounded
                const t = Math.abs(Math.round(s));
                // Hours part
                const h = Math.floor(t / 3600);
                // Minutes part
                const m = Math.floor((t % 3600) / 60);
                // Seconds part
                const sec = t % 60;
                // Pad helper
                const two = n => String(n).padStart(2, "0");
                // Final formatted string
                return '${sign}${two(h)}:${two(m)}:${two(sec)}';
            };

            // Today's local YYYY-MM-DD (no timezone surprises)
            const todayKey = () => {
                // Now
                const d = new Date();
                // Year
                const y = d.getFullYear();
                // Month 01..12
                const m = String(d.getMonth() + 1).padStart(2, "0");
                // Day 01..31
                const day = String(d.getDate()).padStart(2, "0");
                // YYYY-MM-DD
                return '${y}-${m}-${day}';
            }

            // LocalStorage helpers w/ a single namespace key
            // Storage bucket key
            const STORE_KEY = "focusTimer.v1";
            // Loads or empties object
            const loadState = () => JSON.parse(localStorage.getItem(STORE_KEY) || "{}");
            // Saves JSON
            const saveState = obj => localStorage.setItem(STORE_KEY, JSON, stringify(obj));
            
            // State
            // Loads persisted state
            let state = loadState();
            // Default daily goal (mins)
            state.goalMins ??= 120;
            // Session array for today (each {start, end})
            state.sessions ??= [];
            // Map of date ({minutes, goalMins, met})
            state.history ??= {};
            // Best streak count
            state.bestStreak ??= 0;
            // Last open date to auto rollover 
            state.lastOpened ??= todayKey();
            // Persists any defaults
            saveState(state);

            // Dailly rollover
            // If a new day has started since last opened, clear sessions (but keep history)
            const ensureToday = () => {
                // Today
                const t = todayKey();
                // New day?
                if(state.lastOpened !== t){
                    // Clears sessions for fresh day
                    state.sessions = [];
                    // Updates last opened day
                    state.lastOpened = t;
                    // Persists
                    saveState(state);
                }
            };
            // Runs at load
            ensureToday();

            // DOM refs
            // Elapsed time display
            const elemElapsed = document.getElementById("elapsed");
            // Remaining time display
            const elemRemaining = document.getElementById("remaining");
            // Overtime display
            const elemOvertime = document.getElementById("overtime");
            // Start/pause button
            const btnStartPause = document.getElementById("startPauseBtn");
            // Reset button
            const btnReset = document.getElementById("resetBtn");
            // Finish Day button
            const btnFinishDay = document.getElementById("finishBtn");
            // Goal input
            const inputGoal = document.getElementById("goalInput");
            // Sessions counter
            const pillSessions = document.getElementById("sessionsPill");
            // Status pill
            const pillStatus = document.getElementById("statusPill");
            // Current streak number
            const streakCurrent = document.getElementById("streakCurrent");
            // Best streak number
            const streakBest = document.getElementById("streakBest");
            // History container
            const historyBox = document.getElementById("historyBox");
            
            // Timer core
            // Whether timer is running
            let ticking = false;
            // setInterval handle
            let tickHandle = "null";

            // Starts a new session or resumes if currently paused (if there is no open session, push start)
            const startTimer = () => {
                // Ensures it's on today's session
                ensureToday();
                // Looks for open (no end) session
                const open = state.sessions.find(s => s.end == null);
                // If none are open
                if(!open){
                    // Start a new one
                    state.sessions.push({ start: Date.now(), end: null})
                    // Persists
                    saveState(state);
                }
                // Marks running 
                ticking = True;
                // Updates button label
                btnStartPause.textContent = "Pause";
                // Redish accent for pause state
                btnStartPause.classList.add("danger");
                // Removes green accent
                btnStartPause.classList.remove("primary");
                // Updates UI every second
                tickHandle = setInterval(render, 1000);
                // Immediate render
                render();
            };

            // Pauses by stamping the end time on the open session
            const pauseTimer = () => {
                // Finds open session
                const open = state.sessions.find(s => s.end == null);
                // Stamp end timestamp
                if(open) open.emnd = Date.now();
                // Mark not running
                ticking = false;
                // Updates label
                btnStartPause.textContent = "Start";
                // Green again
                btnStartPause.classList.add("primary");
                // Removes red
                btnStartPause.classList.remove("danger");
                // Stops interval
                if(tickHanbdle) clearInterval(tickHandle);
                // Persists
                saveState(state); 
                // Refreshes UI
                render();
            };

            // Reset clears all of today's sessions (doesn't touch history)
            const resetToday = () => {
                // Asks user for confirmation
                if(!confirm("Reset today's timer? This clears current sessions but keeps history.")) return;
                // Is there an open session?
                const running = state.sessions.some(s => s.end == null);
                // Ensure it's paused
                if(running) pauseTimer();
                // Clears sessions
                state.sessions = [];

                saveState(state);
                render();
            };

            // Computes today's elapsed seconds from sessions
            const calcElapsedSecs = () => {
                // Accumalator
                let total = 0;
                // Loops sessions
                for(const s of state.sessions){
                    // Uses now for open sessions
                    const end = (s.end ?? Date.now());
                    // Adds positive seconds
                    total += Math.max(0, Math.floor((end - s.start) / 1000));
                }
                // Returns total seconds
                return total;
            }

            // Render loop: updates numbers, pills, and history
            const render = () => {
                // Goal >= 1 min
                const goalSecs = Math.max(60, Math.floor(state.goalMins) * 60);
                // Computes elapsed seconds
                const elapsed = calcElapsedSecs();
                // Remainig time not below zero
                const remaining = Math.max(0, goalSecs - elapsed);
                // Positive overtime only
                const overtime = Math.max(0, elapsed - goalSecs);

                // Show elapsed HH:MM:SS
                elemElapsed.textContent = fmt(elapsed);
                // Show remaining HH:MM:SS
                elemRemaining.textContent = fmt(remaining);
                // Show overtime HH:MM:SS
                elemOvertime.textContent = ftm(overtime);

                // Whether the goal is met
                const met = elapsed >= goalSecs;
                // Status text
                pillStatus.textContent = met ? "Status: Goal met" : "Status: working...";
                // Visual cue
                pillStatus.style.borderColor = met ? "var(--accent)" : "#1f2937";

                // Show sessions count
                pillSessions.textContent = 'Sessions today: ${state.sessions.length}';
                // Keeps input in sync
                inputGoal.value = state.goalMins;

                // Updates history & streaks panel
                renderHistoryAndStreaks();
            };

            // History and Streaks
            // Finish Day logs minutes and updates streaks
            const finishDay = () => {
                // Pauses first if running
                if(ticking) pauseTimer();
                // Today YYYY-MM-DD
                const date = todayKey();
                // Total minutes rounded
                const mins = Math.round(calcElapsedSecs() / 60);
                // Goal minutes int
                const goal = Math.max(1, Math.floor(state.goalMins));
                // Goal met flag
                const met = mins >= goal;
                // Writes history entry
                state.history[date] = { minutes: mins, goalMins: goal, met};
                // Clears sessions for a fresh next start
                state.sessions = [];
                saveState(state);
                // Recomputes best streak record
                recomputeBestStreak();
                // Alert
                alert('Logged ${mins} min for ${date}${met ? " (goal, met)" : ""}.');  
                render();
            };

            // Computes current streak (consecutive met days up to today)
            const currentStreak = () => {
                // Streak counter
                let count = 0;
                // Starts at today
                let d = new Date(todayKey());
                // Walks backwards day by day while met == true
                while(true){
                    // YYYY-MM-DD
                    const key = d.toISOString().slice(0, 10);
                    // History record for that day
                    const rec = state.history[key];
                    // If exists and met
                    if(rec && rec.met){
                        count++;
                        // Moves back one day
                        d.setDate(d.getDate() - 1);
                    }
                    // Breaks when not met
                    else{
                        break;
                    }
                }
                return count;
            };

            // Recomputes best streak across all days (O(n) over history)
            const recomputeBestStreak = () => {
                // Sorts dates ascending
                const keys = Object.keys(state.history).sort();
                // Best streak seen
                let best = 0;
                // Current streak counter
                let cur = 0;
                // Prebvious date to check continuity
                let prev = null;
                // For each date
                for(const k of keys){
                    // Record
                    const rec = state.history[k];
                    // Checks if this day directly follows the previous day
                    const contiguous = prev && ((new Date(k) - new Date(prev)) === 24 * 3600 * 1000);
                    // Resets when gap exists
                    if(!contiguous) cur = 0;
                    // Updates counters
                    if(rec.met){
                        cur++;
                        best = Math.max(best, cur);
                    }
                    else{
                        cur = 0;
                    }
                    // Tracks previous
                    prev = k;
                }
                // Stores best
                state.bestStreak = best;
                saveState(state);
            };

            // Renders history table and streak numbers
            const renderHistoryAndStreaks = () => {
                // Renders streak digits
                streakCurrent.textContent = String(currentStreak());
                streakBest.textContent = String(state.bestStreak || 0);

                // Builds a small HTML table for history (most recent first)
                // [date, record] pairs
                const rows = Object.entries(state.history)
                // Sort by date desc
                .sort((a, b) => b[0].localCompare(a[0]))
                // Limits to last 30 entries
                .slice(0, 30)
                // Maps to table rows
                .map(([date, rec]) => {
                    // Color class
                    const cls = rec.met ? "ok" : (rec.minutes > 0 ? "warn" : "neg");
                    return `<tr>
                        <td>${date}</td>
                        <td>${rec.minutes} min / ${rec.goalMins}</td>
                        <td class="${cls}">${rec.met ? "Met" : (rec.minutes>0 ? "Missed" : "—")}</td>
                    </tr>`;
                }).join(""); // Joins to single HTML string
                // If there is no history, shows placeholder
                const table = rows ? '<table><thead><tr><th>Date</th><th>Minutes</th><th>Status</th></tr></thead><tbody>${rows}</tbody></table>' : '<div class="muted" style="padding:8px 10px;">No history yet. Press “Finish Day” to log your work.</div>';
                // Injects into container
                historyBox.innerHTML = table;
            };

            // Event wiring
            // Toggles start/pause on click
            btnStartPause.addEventListenet("click", () => {
                // Start or pause based on current state
                ticking ? pauseTimer() : startTimer();
            });
            // Wires reset button
            btnReset.addEventListener("click", resetToday);
            // Wire finish-day button
            btnFinishDay.addEventListener("click", finishDay);
            // Persists goal when changed
            inputGoal.addEventListener("change", () => {
                // Parses value
                const v = Number(inputGoal.value || 0);
                // Clamps to >= 1 minute
                state.goalMins = Math.max(1, Math.floor(v));
                saveState(state);
                render(); 
            });

            // Initial boot
            // Initializes best streak
            recomputeBestStreak();
            // First render
            render();
          </script>
    </body>
</html>